<html><head>
<meta charset="UTF-8">
<title>GMRoomPack cheat sheet</title>
<meta name="viewport" content="width=device-width" />
<meta name="livenode" content="#doc" />
<meta property="theme-color" content="#FFF037" />
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_us" />
<meta property="og:site_name" content="YellowAfterlife" />
<meta property="og:title" content="GMRoomPack cheat sheet" />
<meta property="og:url" content="<!--%[url]-->" />
<meta property="og:description" content="<!--%[desc]-->" />
<script type="text/javascript">
if (document.location.host == "yal.cc" && location.protocol == "http:") {
	document.location.protocol = "https:";
}
</script>
<style type="text/css">
body, #doc tt {
	font: 15px 'Open Sans', sans-serif;
	line-height: 1.35;
}
body {
	margin: 0;
}
.main {
	width: 100%;
	min-height: 100%;
	min-height: 100vh;
	background-color: #f9f9f9;
}
.page {
	max-width: 656px;
	background: #ffffff;
	margin: 0 auto;
	padding: 8px;
	box-shadow: 0 0 0 2px #eee;
	min-height: 100%;
	min-height: 100vh;
	box-sizing: border-box;
}
.page > p:first-child {
	margin-top: 0;
}

#doc, #doc ul, #doc ol {
	padding-left: 0;
	margin: 0;
}
#doc div ul, #doc div ol {
	padding-left: 20px;
}
#doc div ul li {
	list-style: disc;
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px"/></svg>'); 
}

#doc .header {
	display: block;
	outline: none;
	text-decoration: none;
	margin: 0;
	font-weight: 700;
	font-size: 100%;
	color: #458;
	border-left: 2px solid #f3f3f3;/* #f9f9f9*/
	padding-left: 4px;
	padding-top: 1px;
	padding-bottom: 1px;
	cursor: pointer;
}
#doc .header::before {
	display: inline-block;
	content: "+";
	font: 12px monospace;
	border: 1px solid #458;
	line-height: 11px;
	height: 11px;
	width: 11px;
	text-align: center;
	border-radius: 50%;
	margin-right: 4px;
	vertical-align: middle;
	position: relative;
	top: -1px;
}
#doc .item.open > .header::before {
	content: "-";
}
#doc .item.empty > .header::before {
	content: /*"Â·"*/" ";
}
#doc .header:hover {
	border-left-color: #f3f3f3;
	background: #f3f3f3;
}
#doc .header .ret-arrow {
	font-weight: normal;
	margin: 0 0.1em;
}

#doc a.broken {
	color: red;
}
#doc p {
	margin: 0;
}
#doc p + p, #doc p.pad {
	margin-top: 0.5em;
}
#doc img {
	max-width: 100%;
}
#doc h3 {
	margin: 0.25em 0;
	font-size: 125%;
	font-weight: normal;
	border-bottom: 1px solid #ccc;
}

#doc .content, #doc ul {
	padding-left: 20px;
	border-left: 2px solid #f3f3f3;
}
#doc tt {
	font-weight: bold;
}
#doc pre {
	font-family: Consolas, Dejavu Sans Mono, Segoe UI Mono, Ubuntu Mono, Lucida Console, monospace;
	font-size: 9pt;
	line-height: 1.25;
	background: white;
	padding: 4px 2px 4px 10px;
	margin: 0;
	tab-size: 4;
	overflow-x: auto;
	white-space: pre-wrap;
	word-break: break-all;
}
#doc pre a {
	text-decoration: none;
}
#doc pre a.uf {
	background-color: #f7f0ff;
}
#doc pre a.kw {
	background-color: #f0f7ff;
}
#doc pre a.sf, #doc pre a.sv {
	background-color: #fff3f0;
}
#doc pre a:hover {
	text-decoration: underline;
}
#doc abbr[title] {
	text-decoration: underline;
	text-decoration-color: #bbb;
	text-decoration-style: double;
}
/* delay display until load */
#doc[ready] .item:not(.open) > .content {
	display: none;
}
</style>
<style type="text/css" id="md_gml">
/* GameMakerLanguage */
pre.gmlmd .md { color: #7A81A9 } /* #define */
pre.gmlmd .kw { color: #008; font-weight: bold } /* keyword */
pre.gmlmd .co { color: #080 } /* comment */
pre.gmlmd .nu { color: #00f } /* number */
pre.gmlmd .nx { color: #00f } /* hex */
pre.gmlmd .st { color: #00f } /* string */
pre.gmlmd .ts { color: #00f } /* template string */
pre.gmlmd .op { color: #000 } /* operator */
pre.gmlmd .cb { color: #008; font-weight: bold } /* curly brace */
pre.gmlmd .sv { color: #800 } /* std func */
pre.gmlmd .sf { color: #800 } /* std var */
pre.gmlmd .ri { color: #0078aa } /* assets */
pre.gmlmd .uf { color: #808 } /* user func */
pre.gmlmd .uv { color: #000 } /* user var */
pre.gmlmd .lv { color: #648 } /* local var */
pre.gmlmd .fd { color: #804 } /* field */
</style>
<style type="text/css" id="night_css">
#night { display: none }
label[for="night"] {
	color: blue;
	text-decoration: underline;
	cursor: pointer;
}
#night:checked + .main {
	background-color: #405070;
}
#night:checked + .main .page {
	background-color: #1A202D;
	box-shadow: 0 0 0 2px #9bccff63;
	color: white;
}
#night:checked + .main a,
#night:checked + .main a:visited,
#night:checked + .main #doc .header,
#night:checked + .main label[for="night"] {
	color: #9DEC76;
}
#night:checked + .main #doc .header:before,
#night:checked + .main #doc h3 {
	border-color: #9DEC76
}
#night:checked + .main #doc .header,
#night:checked + .main #doc .header:hover,
#night:checked + .main #doc .content,
#night:checked + .main #doc ul {
	border-left-color: rgba(205,225,255,0.1);
}
#night:checked + .main #doc .header:hover,
#night:checked + .main #doc .asset:hover {
	background: rgba(205,225,255,0.1);
}
#night:checked + .main div ul li {
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px" fill="white"/></svg>'); 
}
#night:checked + .main pre {
	color: #cccccc;
	background: #000000;
	border: 1px solid #3E4757;
}
#night:checked + .main pre.gmlmd .op { color: #CCCCCC }
#night:checked + .main pre.gmlmd .co { color: #5B995B }
#night:checked + .main pre.gmlmd .kw { color: #FFB871 }
#night:checked + .main pre.gmlmd .md { color: #FFB871 }
#night:checked + .main pre.gmlmd .cb { color: #FFB871 }
#night:checked + .main pre.gmlmd .sf { color: #FFB871 }
#night:checked + .main pre.gmlmd .uf { color: #FFB871 }
#night:checked + .main pre.gmlmd .nu { color: #FF8080 }
#night:checked + .main pre.gmlmd .st { color: #FCF320 }
#night:checked + .main pre.gmlmd .ts { color: #FF8080 }
#night:checked + .main pre.gmlmd .sv { color: #FF8080 }
#night:checked + .main pre.gmlmd .gv { color: #FF80FF }
#night:checked + .main pre.gmlmd .ri { color: #FF8080 }
#night:checked + .main pre.gmlmd .lv { color: #FFF899 }
#night:checked + .main pre.gmlmd .uv { color: #B2B1FF }
#night:checked + .main pre.gmlmd .fd { color: #B2B1FF }

#night:checked + .main pre.gmlmd a.uf {
	background-color: #431;
}
#night:checked + .main pre.gmlmd a.kw {
	background-color: #431;
}
#night:checked + .main pre.gmlmd a.sf,
#night:checked + .main pre.gmlmd a.sv {
	background-color: #431;
}
</style>
<style>
.main.boxtt #doc tt {
	display: inline-block;
	background: #FFFBE4;
	font-family: Consolas, Ubuntu Mono, Dejavu Sans Mono, Lucida Console, monospace;
	font-weight: normal;
	font-size: 12px;
	line-height: 16px;
	padding: 0 2px;
	border: 1px solid #E6E0C4;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	max-width: 100%;
	word-break: break-word;
}
#night:checked + .main.boxtt #doc tt {
	background-color: #000;
	border-color: #5b7c9f;
	color: white;
}
</style>
<noscript><style>
#doc .header::before {
	display: none;
}
#doc .header:hover {
	border-left-color: #f3f3f3;
	background: inherit;
}
#doc { display: inherit }
#doc .item:not(.open) > .content {
	display: inherit;
}
</style></noscript>
</head><body>
<input type="checkbox" id="night" checked/>
<div class="main <!--%[mainclass]-->">
<script type="text/javascript">
(function() {
	var night = document.getElementById("night");
	var path = "docmd night mode";
	var ls = window.localStorage;
	if (ls) {
		night.checked = ls.getItem(path) == "true";
		night.onchange = function(_) {
			ls.setItem(path, "" + night.checked);
		};
	}
})();
</script>
<div class="page">
<p>This is a "cheat sheet" for GMRoomPack extension by YellowAfterlife.
The extension can be acquired from <a href="https://marketplace.yoyogames.com/assets/7525/_">GM:Marketplace</a> or <a href="https://yellowafterlife.itch.io/gmroompack">itch.io</a>.
For questions/support, use <a href="https://yellowafterlife.itch.io/gmroompack/community">forums</a>, or <a href="mailto://yellowafterlife@hotmail.com">send me an email</a>.
An up-to-date version of this document can always be found <a href="https://yal.cc/r/18/gmroompack">online</a>.</p><p>
Click on sections to expand/collapse them.<br>
Quick display controls: <a href="#" onclick="opt_none(); return false">Categories</a>
&middot; <a href="#" onclick="opt_list(); return false">Sections</a>
&middot; <a href="#" onclick="opt_all(); return false">Everything</a>
&middot; <label for="night">Toggle night mode</label><br/>
</p><div id="doc">
<!--<doc--><div class="item"><span class="header">Setting up and general use</span><div class="content"><p>
	<div class="item"><a class="header" id="setup" href="#setup" title="(permalink)">Setting up</a><div class="content"><ul>
	<li>	Add the extension to your project.
		For GMS1, right-click on Extensions in resource tree and pick "Import"; pick GMEZ;
		For GMS2, drag-and-drop the YYMP onto the workspace area of GMS2 window with your project open in it.
	</li><li>	Add the included files from the extension (prompted during installation).
		These are not needed at runtime and only serve to convert rooms for use with extension.
		That said, it is completely safe to unflag all platforms in their Properties or even move them to a non-project directory.
		On Mac, install <a href="http://nekovm.org/">Neko VM</a> and omit importing .exe/.ndll files.
	</li><li>	Add a completely empty object, say, <tt>obj_blank</tt>
		and assign it to <a href="#room_pack_blank_object">room_pack_blank_object</a>,
		</p><pre class="gmlmd">
<a class="sv" href="#room_pack_blank_object">room_pack_blank_object</a> <span class="op">=</span> <span class="ri">obj_blank</span>
</pre><p>before you call loading functions (usually, on Game Start)
	</li></ul></div></div>
	<div class="item"><a class="header" id="packing" href="#packing" title="(permalink)">Packing rooms</a><div class="content"><ul>
	<li>	On GMS1, double-click GMRoomPack.exe in Included Files
		On GMS2, right-click GMRoomPack.exe (Windows) or GMRoomPack.n (Mac) and pick "Open externally"
		If on Mac and you've not set Neko VM to open .n files, pick "Show in Finder" instead and run server from directory.
	</li><li>	At this point you are presented with a console window asking what you would like to do.
		If you have at least minor experience with CLI, you can check help for arguments, otherwise you can pick options and have it do the work for you.
		Extra note here - to export to a script/included file, you should add a blank script/file prior to the project for GMRoomPack to modify.
	</li></ul></div></div>
	<div class="item"><a class="header" id="loading" href="#loading" title="(permalink)">Loading rooms</a><div class="content"><ul>
	<li>	If you exported room(s) to JSON, you can load them via <a href="#room_pack_load_file">room_pack_load_file</a> (for files containing single rooms) or <a href="#room_pack_load_map">room_pack_load_map</a> (for cached data or a sub-map in a file with multiple rooms).
	</li><li>	If you exported room(s) to scripts, the script will return a new map for the room data upon calling it, which (or a sub-map of which) you can then pass to <a href="#room_pack_load_map">room_pack_load_map</a> and free up later.
	</p><p>
		Loading a single room:
		</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">json</span> <span class="op">=</span> <span class="uf">scr_some</span><span class="op">(</span><span class="op">)</span><span class="op">;</span> <span class="co">// generated from rm_some</span>
<a class="sf" href="#room_pack_load_map">room_pack_load_map</a><span class="op">(</span><span class="lv">json</span><span class="op">)</span><span class="op">;</span>
<span class="co">// and when you're done:</span>
<span class="sf">ds_map_destroy</span><span class="op">(</span><span class="lv">json</span><span class="op">)</span><span class="op">;</span>
</pre><p>Loading from a pack of rooms:
		</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">json_rooms</span> <span class="op">=</span> <span class="uf">scr_rts</span><span class="op">(</span><span class="op">)</span><span class="op">;</span> <span class="co">// generated from rooms starting with rt_</span>
<span class="co">// pick a random room name from the map:</span>
<span class="kw">var</span> <span class="lv">name</span> <span class="op">=</span> <span class="sf">ds_map_find_first</span><span class="op">(</span><span class="lv">json_rooms</span><span class="op">)</span><span class="op">;</span>
<span class="kw">repeat</span> <span class="op">(</span><span class="sf">irandom_range</span><span class="op">(</span><span class="nu">0</span><span class="op">,</span> <span class="sf">ds_map_size</span><span class="op">(</span><span class="lv">json_rooms</span><span class="op">)</span> <span class="op">-</span> <span class="nu">1</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
    <span class="lv">name</span> <span class="op">=</span> <span class="sf">ds_map_find_next</span><span class="op">(</span><span class="lv">json_rooms</span><span class="op">,</span> <span class="lv">name</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span>
<span class="co">// and load that:</span>
<a class="sf" href="#room_pack_load_map">room_pack_load_map</a><span class="op">(</span><span class="lv">json_rooms</span><span class="op">[</span><span class="op">?</span><span class="lv">name</span><span class="op">]</span><span class="op">)</span><span class="op">;</span>
<span class="co">// and when you're done:</span>
<span class="sf">ds_map_destroy</span><span class="op">(</span><span class="lv">json_rooms</span><span class="op">)</span><span class="op">;</span>
</pre><p>Loading a room at callee's XY:
		</p><pre class="gmlmd">
<span class="co">// ...</span>
<a class="sf" href="#room_pack_load_map">room_pack_load_map</a><span class="op">(</span><span class="uv">json</span><span class="op">,</span> <span class="sv">x</span><span class="op">,</span> <span class="sv">y</span><span class="op">)</span><span class="op">;</span>
</pre><p>Loading only instances and tiles from a room at XY:
		</p><pre class="gmlmd">
<span class="co">/// ...</span>
<a class="sf" href="#room_pack_load_map">room_pack_load_map</a><span class="op">(</span><span class="uv">json</span><span class="op">,</span> <span class="sv">x</span><span class="op">,</span> <span class="sv">y</span><span class="op">,</span> <a class="sv" href="#room_pack_flag_instances">room_pack_flag_instances</a> <span class="op">|</span> <a class="sv" href="#room_pack_flag_tiles">room_pack_flag_tiles</a><span class="op">)</span><span class="op">;</span>
</pre><p></li></ul></div></div>
</p></div></div>
<div class="item"><span class="header">Loading rooms</span><div class="content"><p>
	<div class="item"><a class="header" id="room_pack_flag" href="#room_pack_flag" title="(permalink)">room_pack_flag</a><div class="content"><p>
		These are used in <tt>room_pack_*</tt> functions to indicate what you'd like loaded.
		</p><p>
		As they are bit flags, you can combine them via bitwise OR operator <tt>|</tt> or just <tt>+</tt>.
		<div class="item"><a class="header" id="room_pack_flag_settings" href="#room_pack_flag_settings" title="(permalink)">room_pack_flag_settings</a><div class="content"><p>
			Loads settings such as room size and physics setup.
			You probably don't want this if loading a room to an offset in another room.
		</p></div></div>
		<div class="item"><a class="header" id="room_pack_flag_views" href="#room_pack_flag_views" title="(permalink)">room_pack_flag_views</a><div class="content"><p>
			Applies view settings
			You probably also don't want this if loading a sub-room.
		</p></div></div>
		<div class="item"><a class="header" id="room_pack_flag_instances" href="#room_pack_flag_instances" title="(permalink)">room_pack_flag_instances</a><div class="content"><p>
			Loads instances (GMS1) / instance layers (GMS2)
		</p></div></div>
		<div class="item"><a class="header" id="room_pack_flag_backgrounds" href="#room_pack_flag_backgrounds" title="(permalink)">room_pack_flag_backgrounds</a><div class="content"><p>
			Loads backgrounds
			In GMS2, this means background layers, which "stack".
			In GMS1, this means applying background settings, which will override the existing ones.
		</p></div></div>
		<div class="item"><a class="header" id="room_pack_flag_tiles" href="#room_pack_flag_tiles" title="(permalink)">room_pack_flag_tiles</a><div class="content"><p>
			Loads tiles (GMS1) / tilemaps (GMS2)
		</p></div></div>
		<div class="item"><a class="header" id="room_pack_flag_sprites" href="#room_pack_flag_sprites" title="(permalink)">room_pack_flag_sprites</a><div class="content"><p>
			Loads sprites for GMS2 asset layers
		</p></div></div>
		<div class="item"><a class="header" id="room_pack_flag_all" href="#room_pack_flag_all" title="(permalink)">room_pack_flag_all</a><div class="content"><p>
			A combination of all above (use if you want to load <em>everything</em>)
		</p></div></div>
		Default flags are: </p><ul>
		<li>	GMS1: <tt>room_pack_flag_instances | room_pack_flag_tiles</tt>
		</li><li>	GMS2: <tt>room_pack_flag_instances | room_pack_flag_tiles | room_pack_flag_backgrounds | room_pack_flag_sprites</tt>
		</li></ul></div></div>
	<div class="item"><a class="header" id="room_pack_load_file" href="#room_pack_load_file" title="(permalink)">room_pack_load_file(path, x=0, y=0, ?flags)</a><div class="content"><p>
		Loads a room from the specified file.
		</p><p>
		Returns whether successful (fails if file doesn't exist or contains non-JSON data).
		</p><p>
		Creates-destroys a temporary map automatically - no cleanup needed.
		</p><p>
		<a href="#room_pack_flag">Flags</a> indicate what to load.
</p><p>
See <a href="#conf">configuring loader</a> for additional settings.
</p><p>
See <a href="#loading">loading rooms</a> for general instructions.
	</p></div></div>
	<div class="item"><a class="header" id="room_pack_load_string" href="#room_pack_load_string" title="(permalink)">room_pack_load_string(path, x=0, y=0, ?flags)</a><div class="content"><p>
		Loads a room from a string.
		</p><p>
		Returns whether successful (fails if string contains non-JSON data).
		</p><p>
		Creates-destroys a temporary map automatically - no cleanup needed.
		</p><p>
		<a href="#room_pack_flag">Flags</a> indicate what to load.
</p><p>
See <a href="#conf">configuring loader</a> for additional settings.
</p><p>
See <a href="#loading">loading rooms</a> for general instructions.
	</p></div></div>
	<div class="item"><a class="header" id="room_pack_load_map" href="#room_pack_load_map" title="(permalink)">room_pack_load_map(map, x=0, y=0, ?flags)</a><div class="content"><p>
		Loads a room from the specified <tt>ds_map</tt>.
		</p><p>
		Mind that this does not perform JSON validation (for the lack of any built-in functions for doing so) so try to not to pass random garbage instead of room data to it.
		</p><p>
		The input map remains unchanged and can be reused.
		</p><p>
		<a href="#room_pack_flag">Flags</a> indicate what to load.
</p><p>
See <a href="#conf">configuring loader</a> for additional settings.
</p><p>
See <a href="#loading">loading rooms</a> for general instructions.
	</p></div></div>
	<div class="item"><a class="header" id="room_pack_blank_object" href="#room_pack_blank_object" title="(permalink)">room_pack_blank_object</a><div class="content"><p>
		Assign a blank object to this variable before calling any of <tt>room_pack_load_</tt> functions (see <a href="#setup">setting up</a>).
		</p><p>
		This is used to get around the fact that you cannot set things like rotation/scale/color/custom variables for new instances prior to their Create event firing, so instead a blank instance is made, configured, and then <tt>instance_change</tt>-d to the actual thing (with Create event fired via <tt>event_perform</tt>).
	</p></div></div>
</p></div></div>
<div class="item"><a class="header" id="conf" href="#conf" title="(permalink)">Configuring loader</a><div class="content"><p>
	The following functions allow you to configure what and how will be loaded with the next call.
	</p><p>
	Affected settings are reset after a load.
	<div class="item"><a class="header" id="room_pack_store_instances" href="#room_pack_store_instances" title="(permalink)">room_pack_store_instances(list)</a><div class="content"><p>
		Adds all new instance IDs to the specified <tt>ds_list</tt>.
		</p><p>
		(note: does not clear the list prior)
	</p></div></div>
	<div class="item"><a class="header" id="room_pack_store_tilemaps" href="#room_pack_store_tilemaps" title="(permalink)">room_pack_store_tilemaps(list)</a><div class="content"><p>
		For GMS1, adds new tile IDs to the specified <tt>ds_list</tt>.
		</p><p>
		For GMS2, adds new tilemap element IDs to the specified <tt>ds_list</tt>.
		</p><p>
		(note: does not clear the list prior)
	</p></div></div>
	<div class="item"><a class="header" id="room_pack_store_backgrounds" href="#room_pack_store_backgrounds" title="(permalink)">room_pack_store_backgrounds(list)</a><div class="content"><p>
		GMS2 only - stores new background element IDs to the specified <tt>ds_list</tt>.
		</p><p>
		(note: does not clear the list prior)
	</p></div></div>
	<div class="item"><span class="header">room_pack_store_sprites(list)</span><div class="content"><p>
		GMS2 only - stores new sprite (asset layer) element IDs to the specified <tt>ds_list</tt>.
		</p><p>
		(note: does not clear the list prior)
	</p></div></div>
	<div class="item"><span class="header">room_pack_exclude_layer(name)</span><div class="content"><p>
		Skips loading the layer with specified name for the next load.
		</p><p>
		Excluding a parent layer will also exclude it's child layers.
	</p></div></div>
	<div class="item"><span class="header">room_pack_include_layer(name)</span><div class="content"><p>
		Once set, only "included" layers will be loaded.
		</p><p>
		Mind that parent layers also have to be "included".
	</p></div></div>
</p></div></div>
<div class="item"><a class="header" id="cc" href="#cc" title="(permalink)">Supporting variables / creation code</a><div class="content"><p>
	<div class="item"><a class="header" id="room_pack_const_script" href="#room_pack_const_script" title="(permalink)">room_pack_const_script</a><div class="content"><p>
		Set this to a script taking constant name as <tt>argument0</tt> and value as <tt>argument1</tt>, and it will be called for each named instance/tile/layer element.
		</p><p>
		Intended for use if you want to access loaded room's elements by name.
	</p></div></div>
	<div class="item"><a class="header" id="room_pack_eval_script" href="#room_pack_eval_script" title="(permalink)">room_pack_eval_script</a><div class="content"><p>
		If set, this will be called for each instance with it's creation code string / custom variable code as <tt>argument0</tt> and context string (for debug/errors) as <tt>argument1</tt>.
		</p><p>
		For instances, the instance in question will be <tt>self</tt> and the object that called <tt>room_pack_load_</tt> will be <tt>other</tt>.
		</p><p>
		Room creation code is executed for the object that called <tt>room_pack_load_</tt>.
		</p><p>
		Some options: </p><ul>
		<li>	<a href="https://yellowafterlife.itch.io/gamemaker-live">GMLive.gml</a>:
			</p><p>
			If you are already using GMLive and/or need to call arbitrarily complex code,
			you can use it's <a href="https://yal.cc/r/17/gmlive/#live_execute_string">live_execute_string</a> function:
			</p><pre class="gmlmd">
<span class="sv">room_pack_eval_script</span> <span class="op">=</span> <span class="uv">live_execute_string</span><span class="op">;</span>
</pre><p></li><li>	<a href="https://bitbucket.org/yal_cc/txr2/">TXR</a>:
		</p><p>
			TXR is an interpreter for general GML-like code,
			originally <a href="https://yal.cc/interpreters-guide/">as per my guide</a>
			and then further expanded.
			</p><pre class="gmlmd">
<span class="sv">room_pack_eval_script</span> <span class="op">=</span> <span class="uv">txr_exec</span><span class="op">;</span>
</pre><p>(but don't forget to run <tt>txr_init</tt> on game start!)
		</li><li>	<a href="https://forum.yoyogames.com/index.php?threads/free-nsp-2-a-gml-string-interpreter.551/">NSP</a>:
		</p><p>
			Historically regarded as the close second as far as GML coverage goes.
			</p><p>
			Unfortunately, generally requires your creation code to be at least somewhat correct,
			else it may crash.
			</p><pre class="gmlmd">
<span class="sv">room_pack_eval_script</span> <span class="op">=</span> <span class="uv">NSP_execute_string</span><span class="op">;</span>
</pre><p></li><li>	<a href="https://github.com/GameMakerDiscord/execute_string">"execute_string" extension by mintypython</a>:<br/>A more recent candidate, this extension aims to more or less accurately replace the
			deprecated execute_string function.
			</p><pre class="gmlmd">
<span class="sv">room_pack_eval_script</span> <span class="op">=</span> <span class="sv">execute_string</span><span class="op">;</span>
</pre><p></li></ul></div></div>
</p></div></div>
<div class="item"><a class="header" id="tech" href="#tech" title="(permalink)">Technical</a><div class="content"><p>
	<div class="item"><a class="header" id="Room-format" href="#Room-format" title="(permalink)">Room format</a><div class="content"><p>
		For both GMS1 and GMS2, GMRoomPack converts room data to JSON format resembling a simplified version of GMS2 room format.
		</p><p>
		This allows the data to be loaded quickly enough by the extension or by custom code (should you ever want to do something other than loading rooms).
	</p></div></div>
	<div class="item"><a class="header" id="Helper-program" href="#Helper-program" title="(permalink)">Helper program</a><div class="content"><p>
		The helper program takes GMX/YY room files and outputs JSON data for the according version of the extension.
		</p><p>
		It has a command line interface and an interactive mode.
		</p><p>
		CLI doc is as following:
		</p><pre>
GMRoomPack can be used as following:
GMRoomPack [...pairs of input/output paths] &lt;optional flags&gt;
  Converts each input path to it's own output file (see below)
  e.g. GMRoomPack rooms/rm_test/rm_test.yy datafiles/rm_test.json
GMRoomPack [...input paths] --combine [output path] &lt;optional flags&gt;
  Converts and combines all inputs into one output
  e.g. GMRoomPack rooms/rm_one/rm_one.yy rooms/rm_two/rm_two.yy --combine datafiles/rooms.json

Input paths can be as following:
  rm_some.room.gmx, rm_some.yy: converts a single room
  .../project/rooms: converts and combines all rooms
  .../project/rooms/pfx_*: converts and combines all rooms that start with 'pfx_'

Output paths can be as following:
  .../some.json: converts to JSON format
  .../some.gml: converts to a GML script that creates &amp; returns a ds_map with JSON
  Any other extension is assumed to be JSON for now
If multiple rooms are combined into one output file, the top-level structure will have room names as keys and room data as values.

Supported flags:
  --watch: Keeps running and re-converts files on changes
  --prettyprint: Splits JSON into multiple lines to maintain readability
</pre></div></div>
</p></div></div>
<div class="item"><a class="header" id="limitations" href="#limitations" title="(permalink)">Limitations</a><div class="content"><p>
	<div class="item"><span class="header">GMS1 compatibility tile layers in GMS2</span><div class="content"><p>
		For the fact that these only appear in imported GMS1 projects and their <a href="http://docs2.yoyogames.com/source/_build/3_scripting/4_gml_reference/compatibility_functions.html">associated functions</a> are pretty slow, these are currently not supported. While this may change in the future, there's very little reason to use them in production code.
	</p></div></div>
</p></div></div><!--doc>-->
</div></div></div>
<script>(function() {
var doc, headers;
//
var path = "GMRoomPack cheat sheet";
var state = null;
if (window.localStorage && JSON.parse) {
	state = window.localStorage.getItem(path);
	state = state ? JSON.parse(state) : { };
	if (state == null) state = { };
}
var isLocal = (location.host.indexOf("localhost") == 0);
//
function h3bind(h3) {
	var node = h3.parentNode;
	var snip = node.children[1];
	var id = h3.id || h3.textContent;
	h3.snip = snip;
	h3.doc_set = function(z) {
		if (z) node.classList.add("open"); else node.classList.remove("open");
		if (state) {
			state[id] = z;
			window.localStorage.setItem(path, JSON.stringify(state));
		}
	}
	h3.doc_hide = function() {
		this.doc_set(false);
	}
	h3.doc_show = function() {
		this.doc_set(true);
	}
	h3.onclick = function(_) {
		var seen = !node.classList.contains("open");
		h3.doc_set(seen);
		return false;
	};
}
function getHashFunc(id) {
	var node = document.getElementById(id);
	if (node == null) return null;
	return function(e) {
		while (node && node != doc) {
			if (node.classList.contains("item")) {
				node.classList.add("open");
			}
			node = node.parentElement;
		}
	};
}
// Display helpers:
window.opt_none = function() {
	for (var li = 0; li < headers.length; li++) headers[li].doc_hide();
};
window.opt_list = function() {
	for (var li = 0; li < headers.length; li++) {
		var h3 = headers[li];
		if (h3.parentNode.parentNode != doc) {
			h3.doc_hide();
		} else h3.doc_show();
	}
};
window.opt_all = function() {
	for (var li = 0; li < headers.length; li++) headers[li].doc_show();
};
window.live_post = function() {
	doc = document.getElementById("doc");
	headers = doc.getElementsByClassName("header");
	//
	for (var i = 0; i < headers.length; i++) h3bind(headers[i]);
	// Clicks in document expand the related section:
	var anchors = doc.getElementsByTagName("a");
	for (var i = 0; i < anchors.length; i++) {
		var anchor = anchors[i];
		if (anchor.classList.contains("header")) continue;
		var href = anchor.getAttribute("href");
		if (href[0] == "#") {
			var fn = getHashFunc(href.substr(1));
			if (!fn) {
				anchor.classList.add("broken");
				anchor.title = "(section missing)";
			} else anchor.addEventListener("click", fn);
		}
	}
	//
	for (var li = 0; li < headers.length; li++) {
		var h3 = headers[li];
		var val = state ? state[h3.id || h3.textContent] : null;
		if (val == null) val = isLocal || h3.parentNode.parentNode == doc;
		if (val) h3.doc_show(); else h3.doc_hide();
	}
};
window.live_post();
//
(function() {
	var hash = document.location.hash;
	if (hash) {
		var _hash = hash.substr(1);
		getHashFunc(_hash)();
		setTimeout(function() {
			document.location.hash = hash + " ";
			setTimeout(function() {
				document.location.hash = hash;
			}, 100);
		}, 100);
	}
})();
//
doc.setAttribute("ready", "");
})();
</script>
</body></html>
